# Java内存区域
**维基百科**  

> Java虚拟机（英语：Java Virtual Machine，缩写为JVM），一种能够运行Java bytecode的虚拟机，以堆栈结构机器来进行实做。最早由SUN微系统所研发并实现第一个实现版本，是Java平台的一部分，能够运行以Java语言写作的软件程序。

> Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。通过对中央处理器（CPU）所执行的软件实现，实现能执行编译过的Java程序码（Applet与应用程序）。

> 作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件符合JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。此外，除了甲骨文，也有其他开源或闭源的实现。  

从[编码](https://book.douban.com/subject/4822685/)一书中，我们可以很清楚的知道人类的信息可以通过计算机存储和处理，而且由于计算机速度的飞速发展，这一优势也显示的淋漓尽致。

现代计算机的模型就不得不说道冯·诺伊曼结构。

**维基百科** 

> 冯·诺伊曼结构（英语：Von Neumann architecture），也称冯·诺伊曼模型（Von Neumann model）或普林斯顿结构（Princeton architecture），**是一种将程序指令存储器和数据存储器合并在一起的计算机设计概念结构**。本词描述的是一种实现通用图灵机的计算设备，以及一种相对于并行计算的序列式结构参考模型（referential model）。

> 本结构隐约指导了将存储设备与中央处理器分开的概念，因此依本结构设计出的计算机又称存储程序计算机。

从中我们可以看出指令和数据都是存储在存储器中（也就是我们说的内存），而JVM也是符合冯·诺伊曼结构。  
JVM在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有的则依赖用户线程的启动和结束而建立和销毁。  

![Java虚拟机运行时数据区](http://images2017.cnblogs.com/blog/632650/201709/632650-20170920231114712-718663561.png)

***什么是线程：CPU执行时间加上指令加上内存（自己的理解）***

**程序计数器**  
线程私有的，主要作用是为了线程切换后能恢复到正确的位置，记录的是正在执行的虚拟机字节码指令的地址
**Java虚拟机栈**  
线程私有的，主要作用是为了记录指令的执行信息，在入栈的时候会创建一个栈帧，里面用来记录局部变量表 操作数栈 动态链接 方法出口等信息  
**本地方法栈**   
线程私有的，主要作用跟Java虚拟机栈非常相似，Java虚拟机栈是为了Java字节码服务的，而本地方法栈是为了原生方法服务的，也就是Native方法，说白了就是当前实现JVM语言（一般是c++)  
**Java堆**  
线程共享的，主要作用是为了存放对象实例，个人理解也就是冯·诺伊曼结构中数据的部分  
**方法区**  
线程共享的，主要作用是为了存储已被虚拟机加载的类信息 常量 静态变量 代码等数据（Java1.7），个人理解也就是冯·诺伊曼结构中指令的部分 

**详细讨论方法区**  

谈到常量池，在Java体系中，共用三种常量池。分别是**字符串常量池**、**Class常量池**和**运行时常量池**。

**1.字符串常量池是什么**？

> 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。
> 在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；

字符串常量池在java1.7之后已经移动到了heap中，可以用以下代码进行测试（为了使代码迅速生效，可以设置堆的大小-Xmx1m ）：

```java
//运行如下代码探究常量池的位置  
public static void main(String[] args) {
    List<String> list = new ArrayList<String>();
    int i=0;
    while(true){
        list.add(String.valueOf(i++).intern());
    }
}

//异常信息(部分)
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space  
```

**2.Class常量池是什么**？

> Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。
>
> 字面量包括：在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。
>
> 符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。

**Class常量池有什么用？**

> 在《深入理解Java虚拟》中有这样的表述：
>
> Java代码在进行`Javac`编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在虚拟机类加载过程时再进行详细讲解。
>
> 前面这段话，看起来很绕，不是很容易理解。其实它的意思就是： Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中。

**3.运行时常量池是什么？**

> 运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用
>
> JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。



**直接内存**

> 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。
>
> JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。
>
> 本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

java8移除了方法区，把方法区的数据移动到了元空间（使用本地内存）。

机器的内存是有上限的，所以需要有个机制来清理内存。  
**Java虚拟机栈** **本地方法栈** **程序计数器**随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行出栈入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来就是已知的，因此这三个区域的内存分配和回收都具有确定性，在这几个区域就不需要过多考虑回收的问题。我们所需要管理的就剩下**Java堆**和**方法区**，我们给这个机制命名为垃圾收集。



